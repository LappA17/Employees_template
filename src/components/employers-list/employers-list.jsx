import EmployersListItem from '../employers-list-item/employers-list-item';

import './employers-list.css';

/* item - это всё тот же объект и мы его можем диструтуризировать немножко по другому, то-есть вытащим одну перемуню id (const {id ),
а все остальные пропсы которые у нас там остались мы объединяем в одно свойство которое называется itemProps. 
То-есть мы вытаскиваем только id, а всё остальнео (нейм, селери, инкрис пойдет дальше) */

const EmployersList = ({data}) => {

    const elements = data.map(item => {
        const {id, ...itemProps} = item;
        return(
            <EmployersListItem key={id} {...itemProps}/>
        )
    })

    return (
        <ul className="app-list list-group">
            {elements}
        </ul>
    )
}
    export default EmployersList;

/* У нас ошибка в консоли, которая говорит что кажлый элемент списка должен иметь свой ключ, причем это свойство.
Ваня сказал что проще всего впихнуть какой-то ключ, но нужно капнуть глубже и понять в чем проблема и как работает РЕАКТ. Дело в том
что веб-приложение - динамичные, данные приходят и уходят, все меняется. При всех этих манипуляциях постоянно меняется ДОМ структура
меняется интерфес. Работа с ДОМ структурой - очень тяжелый процес. Сама дом структура настроена на статику, одно из решений - Виртуал Дом
Представь что в нашем веб-приложение не 3 сотрудника , а 300, и в середина появился один, а другой удалился, реакт должен перестроить
все 300 компонентов или измнить только того что поменялся и как поменять ДОМ структуры что бы все это было оптимизировано. 
    И вот здесь вступате алогритм согласования или РЕКАНСЕЛЯЦИИ. Как он работает: у нас есть ul в котором лежам все эти элементы и вдруг
произойдет в нашем приложение что-то такое что ul поменяется на div , те будет вот так <div className="app-list list-group"> {elements} </div>,
то Реакт думает рас уж поменялась корневая сущность то все внутри тоже поменялось и при этом идет полное уничтожение ДОМ дерева и весь
список elements тоже будет уничтожен и приложение будет создано заново. ТОЕСТЬ ЕСЛИ МЕНЯЕТСЯ КОРНЕВОЙ ЭЛЕМЕНТ ТО ВСЕ 300 ВНУТРИ ТОЖЕ
УНИЧТОЖАТЬСЯ И ПОМЕНЯЮТСЯ !
    Теперь представим что меняется не корневой тег, а просто аттрибуты, какие-то проксы или атрибуто класса, дата-атрибут, то Реакт
будет обновлять ТОЛЬКО ИЗМЕНИВШЕЙСЯ ЭЛЕМЕНТ. Если мы добавим какой-то новый класс в <ul className="app-list list-group"> то сначала
уничтожен будет ТОЛЬКО ТЕГ ul, не цепляя внутрености, и заменен на другой тег ul с тем и же внутреностями. У нас элементы - НЕИЗМЯНЕМЫЕ,
мы можем поменять их на странице только если их ПОЛНОСТЬЮ ПЕРЕРЕНДЕРИМ.
    Дальше алгорит пойдет РЕКУРСИВНО, те ПО ВСЕМ ДОЧЕРНЕМ ЭЛЕМЕНТАМ которые находятся внутри корневого элемента. Но то как работает
это внутри очень интересно, потому что Реакт сохраняет коппию предыдущих элементов и компонентов(те у нас это {elements}), но при
этом сохраняте новое дерево которое должно быть построенно и все это происходит в Виртуал Дом дереве, дальше идет одновременное сравнение
каждого элемента друг с другом, то-есть <EmployersListItem сравнивается с таким же компонентом <EmployersListItem который должен быть
зарендерен и если Реакт находит в них отличие, то измененые элементы будут создавать мутацию, то-есть создавать перерисовку в реальном
ДОМ дереве(те Реакт изменит в реальном ДОМ дереве ТОЛЬКО ТЕ ЭЛЕМЕНТЫ КОТОРЫЙ ДЕЙСТВИТЕЛЬНО ИЗМЕНИЛИСЬ, ОСТАЛЬНЫЕ БУДЕТ НЕ ТРОНУТЫМИ)
    Здесь есть одна большая проблема касаемо ОДИНАКОВЫХ ЭЛЕМЕНТОВ, сейчас у нас элементы из лист айтем. И если идет список с одинаковыми
сотрудниками то КАК СКРИПТ ПОНИМАЕТ ЧТО СОТРУДНИК ИЗМЕНИЛСЯ ? На базовом уровен у нас идет сравнение просто по порядку. В app.js
сначала у нас идет Руслан, потом Лиза и Эдвард, и наш Реакт понимает что нужно сравнивать по порядку, те что на первом месте у нас
Руслан и тд. И если мы добавим 4 элемент какого-то Ивана на последнею позицию, то первые три изменены не будут, Реакт сначала сравнит
первые три компонента, поймет что они остались точно такие же и просто дорисует 4го. НО ЕСЛИ МЫ ПОСТАВИМ ИВАНА НА ПЕРВУЮ ПОЗИЦИЮ
ТО РЕАКТ БУДЕТ ДУМАТЬ ЧТО ВЕСЬ НАШ СПИСОК ПОМЕНЯЛСЯ ПОТОМУ ЧТО ТОТ ЭЛЕМЕНТ ЧТО БЫЛ НА 1ом МЕСТЕ СТАЛ 2 И ТАК ДАЛЕЕ ПО ЦЕПОЧКЕ И 
СЕЙЧАС ОЧЕНЬ ВАЖНО - РЕАКТ БУДЕТ ДУМАТЬ ЧТО ВЕСЬ СПИСОК ПОМЕНЯЛСЯ И БУДЕТ ПЕРЕРИСОВЫВАТЬ КАЖДЫЙ ИЗ ЭТИХ КОМПОНЕНТОВ, ДАЖЕ ЕСЛИ 300 И 
ЭТО СИЛЬНЕЙШИЙ УДАР ПО ОПТИМИЗАЦИИ !!! И НАМ НУЖНО ЧТО-ТО ЧТО БУДЕТ ГОВОРИТЬ РЕАКТУ ЧТО ЭТО ВСЕ ТОТ ЖЕ КОМПОНЕНТ, ЧТО БЫ ЕГО НЕ МЕНЯТЬ
И ВОТ ТАКИМ ВОТ ИНДИФИКАТОРОМ ЯВЛЯЕТСЯ АТТРИБУТ key ИМЕННО ПО НЕМУ РЕАКТ БУДЕТ ОПРЕДЕЛЯТЬ МЕНЯЛСЯ ЛИ ЭЛЕМЕНТ ИЛИ НЕТ */